{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Sentry","body":"# Sentry - Simple process monitoring\r\n\r\nThis project is in early stage.\r\n\r\nSentry is a process monitoring tool written and configured in Haskell. Its aim\r\nis to keep running programs. For each configured program (called an entry in\r\nits configuration) , multiple processes can be started.\r\n\r\nCurrently Sentry runs on Linux only.\r\n\r\n## Install\r\n\r\nThe development version can be installed by cloning the Git repository and\r\nusing cabal:\r\n\r\n    > git clone git://github.com/noteed/sentry.git\r\n    > cd sentry && cabal install\r\n\r\n## Usage\r\n\r\nSentry is written in Haskell and is also configured in Haskell. The principle\r\nis to write a short script in `~/.sentry/conf/`. For instance a `sample.hs`\r\nconfiguration would look like the following:\r\n\r\n    import Sentry.Server\r\n\r\n    main :: IO ()\r\n    main = sentry\r\n      [ entry \"dummy\" \"sleep\" [\"4\"] 1000 1\r\n      ]\r\n\r\n`\"dummy\"` is the entry name, also called the process type. `\"sleep\"` and\r\n`[\"4\"]` is the command that need to be run (and kept running), together with\r\nits arguments. The `1000` value specifies how long in milliseconds Sentry has\r\nto wait before restarting the command when it dies. Finally `1` is the number\r\nof processes you want to run that particular process type. You can then compile\r\n`sample.hs` and obtain a `sample` binary like this:\r\n\r\n    > ghc --make -threaded sample.hs\r\n\r\nStart your Sentry with:\r\n\r\n    > ~/.sentry/conf/sample start\r\n\r\nSentry will save its PID to `sample.pid` and start running the \"dummy\" entry:\r\n\r\n    Sentry started (PID: 1511s aved in /home/thu/.sentry/conf/sample.pid).\r\n    20:17:51 dummy.1514      Started at 1334081871.\r\n    20:17:55 dummy.1514      Exited at 1334081875 with ExitSuccess.\r\n    20:17:56 dummy.1516      Started at 1334081876.\r\n    20:18:00 dummy.1516      Exited at 1334081880 with ExitSuccess.\r\n    ^CBye.\r\n    >\r\n\r\nWhenever `sleep` exits, Sentry will run it again, and again.\r\n\r\nRecompiling a configuration (i.e. `sample.hs` in the example) can be done while\r\nSentry is running. A SIGHUP will instruct Sentry to re-exec itself, using the\r\nnew configuration. The command (while Sentry is already running)\r\n\r\n    > ~/.sentry/conf/sample reload\r\n\r\nwill just do that:\r\n\r\n    > .sentry/conf/sample start\r\n    Sentry started (PID: 1530saved in /home/thu/.sentry/conf/sample.pid).\r\n    20:32:01 dummy.1536      Started at 1334082721.\r\n    20:32:05 dummy.1536      Exited at 1334082725 with ExitSuccess.\r\n    /home/thu/.sentry/conf/sample.hs successfully compiled.\r\n    Sentry reexec'd. Initially started at 1334082711 (Previously reexec'd at 1334082711).\r\n    20:32:08 dummy.1550      Started at 1334082728.\r\n    20:32:12 dummy.1550      Exited at 1334082732 with ExitSuccess.\r\n    ^CBye.\r\n    >\r\n\r\n## HTTP interface\r\n\r\nSentry has an embedded web server to exposes its state over HTTP. It is also\r\nused to accept reconfiguration commands (e.g. scale a given process type).\r\n\r\n## Documentation\r\n\r\nThis `README.md` file should be a good starting point. Additional information\r\ncan be found in the Haddock pages. Those pages are currently available from\r\nhttp://hypered.be/haddock/sentry.\r\n\r\n## Design\r\n\r\nSentry is configured with a list of process specifications. For each\r\nspecification, multiple processes can be spawn and monitored.\r\n\r\nSentry spawns a process by forking itself and then exec'ing the process'\r\ncommand. Waiting for the process to complete is done in a lightweight thread.\r\nForking and waiting a child process is a more accurate way to know when the\r\nprocess dies than polling. (Another good way to do that is to use netlink with\r\nthe process events connector.)\r\n\r\nA main thread reads commands from a concurrent queue (a `Chan` in Haskell).\r\nCommands are pushed by signal handlers and monitoring threads to instruct the\r\nmain thread to act on its configuration (and thus change its set of monitored\r\nprocesses).\r\n\r\n## TODO\r\n\r\n- Dynamically resize the number of processes for a specific entry.\r\n- Let Sentry start a configuration instead of manually run it. I.e.\r\n  `sentryd start -c sample` instead of `~/.sentry/conf/sample`. Default\r\n  configuration could be `sentry.hs`.\r\n- Separate data types for save/restore (i.e. with SafeCopy instances) and\r\n  data types actually used at runtime.\r\n- Build on 7.0 and 7.4 (was tested only on 7.0.3 so far).\r\n","google":"","tagline":"Simple process monitoring"}